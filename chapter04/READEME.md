> 더 자세한 내용은 [이곳](https://yeindianamoon.notion.site/Chapter-04-535b81f593c7424fb42cdd4d298c33c1?pvs=4)에 정리되어있습니다 :)

<br />

# Chapter 04. 테스트 구축하기

**JUnit**는 켄트 백과 에릭 감마가 개발한, 스몰토크 버전 단위 테스트를 자바로 포팅한 프레임워크로, 수많은 언어용 테스트 프레임워크가 만들어지는 기반이 되었다.

**테스트코드는 기능 추가 전에 작성하자.** 

이는 단순 구현보다 인터페이스에 집중할 수 있도록 하며, 개발이 끝나는 시점을 테스트를 모두 완료하는 시점으로 생각할 수 있으니 기간 산정에도 용이하다.

하지만 TDD에 앞서, **모든 기능에 대한 테스트는 지양해야함**을 다시 한번 기억해야한다.

테스트의 목적은 어디까지나 버그를 찾는 것에 있기 때문에, 단순 접근자에 대한 테스트는 하등 필요 없다. 이런 테스트가 늘어나면 정작 중요한 테스트를 놓치기 쉽상이다. 복잡하고 가장 걱정되는 영역에 집중해야한다.

<br />

## 예제

간단한 예제로 테스트코드 작성 방법을 알아보자. UI, 영속성, 외부 서비스 연동에 대해서는 배제한다.

실제 개발시에도 비즈니스 로직이 복잡하다면 UI와 분리하는 습관을 가지자!

<br />

## Mocha를 이용한 테스트

> **빨간 막대**일 때는 리팩토링 하면 안된다!

### ⚙️ 기본 세팅

```jsx
import { expect } from "chai";

describe("province", () => {
  it("shortfall", () => {
    const asia = new Province(sampleProvinceData());
    expect(asia.shortfall).equal(5);
  });
});
```

1. **픽스처 설정**
    
    테스트에 필요한 객체를 설정한다.
    
2. **픽스처 속성 검증**
    - 주어진 값에 대해 기대값과 동일한 계산을 하는지 확인한다.
        
        픽스처 검증을 위해 다양한 어서션(assertion)을 사용할 수 있는데, 예제에서는 **chai** 라이브러리를 이용하며 assert문 대신 expect 문을 활용하고있다.
        
    - it 블록 하나 당 하나의 속성만 검증해야한다.
        
        하나의 it 구문에 여러 속성을 검증하다보면 실패 시점 기준 뒷 부분은 실행해보지도 못하고 끝나게 되는데, 그러면 실패 원인을 파악하는데 유용한 정보를 놓치기 쉽다.
        

❗ ES6로 mocha를 사용할 때 유의할 점 ([레퍼런스](https://stackoverflow.com/questions/46487307/is-it-possible-to-use-es6-modules-in-mocha-tests))

- **package.json**에 `"type": "module"` 를 명시한다.
- import시 **확장자** (`.js`)를 명시한다.

<br />

### 👩‍🏫 기댓값 계산하기

예제는 간단한 축에 속하지만, 실제로는 복잡한 로직이 있어 기댓값을 계산하기 어려울 수 있다. 이럴 때는 다음 과정을 수행해보자.

1. **임시 값 설정** 
    
    코드가 바를 것을 기대하고 `expect(테스트 타겟).equal(임의의 값)` 수행한다.
    
2. **기댓값을 실제 값으로 대체**
    
    1. 에서 설정했던 임시 값을 테스트로 얻은 `실제 값` 으로 기댓값 대체한다.
    
3. **오류 주입으로 기댓값 검증**
    
    계산 로직에 오류를 주입해 테스트가 오류를 걸러낸다면, 2. 의 `실제 값` 을 기댓값으로 사용할 수 있다.
    
<br />

### 🔎 중복 체크하기

일반 코드와 마찬가지로 테스트 코드에서도 중복은 의심해야한다.

```jsx
describe("province", () => {
  it("shortfall", () => {
    const asia = new Province(sampleProvinceData());
    expect(asia.shortfall).equal(5);
  });
});

describe("profit", () => {
  const asia = new Province(sampleProvinceData());
  expect(asia.profit).equal(230);
});
```

```jsx
describe("province", () => {
  let asia;
  beforeEach(() => {
    asia = new Province(sampleProvinceData());
  });

  it("shortfall", () => {
    expect(asia.shortfall).equal(5);
  });

  it("profit", () => {
    expect(asia.profit).equal(230);
  });
});
```

동일 픽스처 기반의 두 테스트의 중복을 제거하려면 어떻게해야할까? 답은 `**beforeEach` 문 활용하기**이다.

- 단순히 상위로 올려 통합하는 것은 바람직하지 않다.
    
    테스트끼리 상호작용하는 공유 픽스처는 실행 순서에 따라 각 테스트가 성공할 수도, 실패할 수도 있게끔 만들어 테스트의 신뢰도를 낮춘다.
    
- 표준 픽스처를 만드는 역할을 한다.
    
    위 `beforeEach` 는 모든 `it` 블록마다 픽스처를 정의하는 것과 동일한 역할을 하지만, 각 테스트에서 사용되는 픽스처가 똑같은 기준 데이터로부터 시작한다는 사실을 쉽게 알 수 있다.
    

***c.f. 픽스처 내일 만들어지겠네***

생성하는데 너무 오래 걸려 여러 테스트가 공유할 수 밖에 없는 픽스처가 있을 수 있다.

그럴 때는 **해체(teardown) 혹은 청소(cleanup) 단계**를 거쳐 변경된 픽스처가 테스트 사이에 영향을 주지 않도록 한다.

<br />

### 🧪 테스트 패턴

실제로는 사용자가 값을 변경해 픽스처의 내용이 수정되는 경우가 흔하다. 

이러한 사용자 실행 단계를 포함한 테스트 패턴을 아래와 같이 표현한다.

> **설정-실행-검증** (setup-exercise-verify)
> 
> 
> **조건-발생-결과**(given-when-then)
> 
> **준비-수행-단언**(arrange-act-assert) 
> 

필요에 따라 공통된 초기 준비 작업을 표준 설정 루틴(beforeEach와 같은)에 모아 처리하기도 하고, 세가지 단계를 한 테스트 안에 포함시키기도 한다.

<br />

### 💣 경계 조건 검사하기

우리 의도대로 사용하지 않는 이상한 사용자에 빙의한 테스트도 준비해야한다.

1. 참조형일 때, 빈 배열 혹은 빈 객체
2. 숫자일 때, 0 혹은 음수

이러한 경계 조건(정상적이지 않은 경우)에서 어떻게 처리해야할지 생각해볼 수 있다. 

예를 들어, **수요를 음수로 설정했을 때**의 **수익**을 사용자 관점에서 고려하면 음수보다는 0 또는 에러를 반환하는 것이 더 적합할 것이다. 

<br />

만약 필드에 **예상치 못한 타입**이 입력되었을 때는 어떻게 될까?

모카는 실패와 에러를 구분하지 않아 실패로 처리한다. (두 가지를 구분해주는 프레임워크도 많다.)

- 실패 : 검증 단계에서 실제 값이 예상 범위를 벗어남
- 에러 : 검증 보다 앞선 과정에서 예외 발생

<br />

*우리는 타입스크립트를 사용하니까 걱정을 조금 덜 수 있다.* 😮‍💨  (실패가 아닌) 에러를 처리하기 위해서 이렇게 해볼 수 있겠다.

1. 더 의미있는 에러 메세지를 출력하도록 코드를 추가한다.
2. producers가 원하지 않은 형태로 입력되었을 때 기초값을 빈 배열로 설정한다.
3. 외부에서 들어온 입력 객체에 대한 유효성 검사를 실행한다.
